\chapter{SPECIFICAȚII ȘI REPREZENTAREA APLICAȚIEI}
Aplicația Fast Ride este construită folosind o arhitectură scalabilă, bazată pe microservicii și servicii în cloud. Tehnologiile principale utilizate sunt Blazor WebAssembly pentru interfața utilizator și Azure Durable Functions pentru logica de backend. Comunicarea dintre cele două componente este realizată prin API-uri HTTP și prin WebSocket-uri cu ajutorul SignalR.
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/componentsComunication.png}
    \caption{Comunicarea dintre componentele proiectului}
    \label{fig:componentsComunication}
\end{figure}

\section{Arhitectura aplicației}
Aplicația dispunde de trei nivele:
\begin{itemize}
    \item stocare - unde se păstrează informațiile
    \item server-side - unde se prelucrează toate infomațiile
    \item client-side - unde se afisează toate informațiile către utilizatori
\end{itemize}

\subsection{Stocare}

Azure Table Storage este o bază de date NoSQL, ideală pentru scenarii în care se lucrează cu volume mari de date structurate,
dar fără relații complexe între entități. În cazul aplicației FastRide, fiecare entitate: utilizatori, curse, șoferi online și instanțele de orchestrare, este reprezentată ca o tabelă separată în Table Storage. Fiecare înregistrare (sau entitate) dintr-o tabelă este identificată în mod unic printr-o combinație de \textit{PartitionKey} și \textit{RowKey}, ceea ce asigură o distribuire eficientă și acces rapid la date.
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/ER.png}
    \caption{Diagrama ER pentru baza de date.}
    \label{fig:ER}
\end{figure}

Aplicația FastRide conține trei entități, fiecare reflectând o componentă critică a
funcționalității sistemului: utilizatorii, cursele și șoferii online.

Totul pornește de la entitatea \textit{Users}, care stochează informațiile de bază ale fiecărui utilizator autentificat prin Google.
Fiecare utilizator este identificat în mod unic prin \textit{NameIdentifier} și \textit{Email}, iar alături de acesta se păstrează date precum numele (\textit{Username}), tipul de utilizator (\textit{Driver}, \textit{User} sau \textit{Admin}), ratingul acumulat de-a lungul timpului, numărul de telefon și o eventuală poză de profil (\textit{PictureUrl}).

În momentul în care un utilizator rezervă sau preia o cursă, se creează o relație între acesta și instanțele de orchestrare.
Aici intervin tabelele \textit{TaskHubInstances} și \textit{TaskHubHistory}, care reflectă intern mecanismul
de orchestrare al Azure Durable Functions. Fiecare instanță a unei funcții durabile este stocată în \textit{TaskHubInstances}, iar starea
sa (\textit{CustomStatus}) este utilizată pentru a reflecta progresul unei curse (\textit{Ride}). În paralel, \textit{TaskHubHistory} păstrează detaliile cronologice ale
execuției, istoricul exact al fiecărei acțiuni legate de instanța respectivă. Ambele entități sunt identificate prin \textit{PartitionKey}, iar
în cazul istoricului, și prin \textit{RowKey}.

Starea unei curse este gestionată de modelul \textit{Ride}, care este corelat cu Users prin câmpul \textit{UserIdentifier}, indicând clientul
care a inițiat cererea. Dacă un șofer acceptă cursa, acesta este reprezentat prin \textit{DriverIdentifier}. Fiecare cursă este
caracterizată de un status:
\begin{itemize}
    \item \textit{NewRideAvailable} - status-ul inițial al cursei
    \item \textit{GoingToUser} - momentul în care șoferul acceptă cursa și navighează către client
    \item \textit{GoingToDestination} - atunci când șoferul merge spre destinație împreună cu pasagerul
    \item \textit{Finished} - cursa este finalizată cu success
    \item \textit{Cancelled} - cursa a fost anulată
    \item \textit{None} - state-ul inițial
\end{itemize}
Mereu după ce cursa se termina, aceasta se setează pe state-ul inițial.
Pentru a face vizibil în continuare statusul final al cursei, această memorează și un \textit{CompletedStatus} :
\begin{itemize}
    \item \textit{DriverNotFound} - nu s-a găsit niciun șofer pentru a finaliza cursa
    \item \textit{PaymentRefused} - clientul a refuzat plata (disponibilă doar cu cardul)
    \item \textit{Cancelled} - cursa este anulată din orice alte motive
    \item \textit{Completed} - cursa a fost terminată cu success
\end{itemize}
În infomațiile cursei se mai regăsesc și punctul de plecare (\textit{StartPoint}),
destinația (\textit{Destination}) și costul asociat. \textit{GroupName} este folosit pentru a lega această entitate de sesiunea real-time
corespunzătoare, utilă pentru actualizări prin SignalR, astfel încât, doar șoferii din același grup cu clientul ce a inițiat cursa pot interacționa.


Pe lângă aceste entități persistente, aplicația păstrează în mod temporar o listă cu șoferii activi prin tabela \textit{OnlineDrivers}.
Fiecare șofer online este identificat prin \textit{NameIdentifier} și asociat cu \textit{GroupName}, astfel încât să poată fi notificat
în timp real dacă există cereri în zona sa. Poziția sa curentă este păstrată prin coordonatele \textit{Latitude} și \textit{Longitude},
permițând localizarea sa pe hartă.

Azure Table Storage oferă performanță, scalabilitate și costuri reduse, iar modelul este suficient
de flexibil pentru a susține dezvoltări ulterioare, cum ar fi introducerea plăților reale, recenziilor textuale
sau programării curselor în avans.

\subsection{Server-side}

Backendul aplicației este construit folosind .NET și Azure Functions, oferind o arhitectură
serverless, scalabilă și eficientă pentru gestionarea întregii logici din spatele aplicației.
Totul pornește de la faptul că aplicația este construită într-un mod în care clientul
(Blazor WebAssembly) comunică prin HTTP și SignalR cu backendul, trimițând cereri sau
ascultând în timp real anumite evenimente.

Structura proiectului Server, este cuprinsă din mai multe layere: function triggers, orchestrations,
activities, services și repositories.

\textit{Function triggers} sunt de 3 tipuri: \textit{HttpTrigger}, \textit{TimeTrigger} și \textit{SignalRTrigger}.

HttpTriggers sunt folosite pentru comunicarea cu Client-side, și sunt requesturi de tipul Get/Post și Put.
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/HttpTrigger.png}
    \caption{Exemplu de metodă GET pentru HttpTrigger function.}
    \label{fig:HttpTrigger}
\end{figure}

Aceste request-uri sunt autorizate prin Google token. Astfel s-a creat un atribut custom,
ce poate fi folosit doar pe methods, unde se pot defini o listă de \textit{roles} ce pot
accesa metoda respectivă.
Ca și request, body-ul este incapsulat în modelul \textit{HttpRequest} și poate fi deserializat
astfel:
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/DeserializeRequest.png}
    \caption{Deserializarea unui request într-un tip concret (ex: \textit{UserIdentifier}).}
    \label{fig:DeserializeRequest}
\end{figure}

Ca și răspuns, toate Http functions întorc un \textit{IActionResult} ce este mapat dintr-un extension
pentru un \textit{ServiceResponse}. Acest model conține statusul request-ului, mesajul de eroare (dacă
există) și payload-ul response-ului. Toate service-urile conțin returnează un \textit{ServiceResponse}
care la fel, conține payload-ul, dacă este cu succes sau nu și mesajul de eroare împreună cu excepții.
Dacă există mesaj de eroare atunci rezultatul este un \textit{Bad Request (400)}, iar dacă există
excepție atunci se traduce ca \textit{Internal Server Error (500)}.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/HttpResponse.png}
    \caption{Maparea unui \textit{ServiceResponse} la \textit{IActionResult}.}
    \label{fig:HttpResponse}
\end{figure}

Metodele HTTP disponibile pentru Client sunt:
\begin{itemize}
    \item \textit{GetCurrentUserAsync} pentru a lua informațiile despre user-ul de a inițiat requestul;
    \item \textit{GetUserAsync} pentru a lua informațiile despre un user;
    \item \textit{GetUsers}, disponibil doar pentru admini, pentru a vedea toți utilizatorii;
    \item \textit{UpdateUserAsync} pentru a actualiza un user;
    \item \textit{GetRidesByUserAsync} pentru a afișa cursele unui utilizator
\end{itemize}

Pentru a autoriza aceste endpoint-uri, în Azure Functions se pot înregistra \textit{middleware} pentru 
a verifica token-ul. Astfel \textit{AuthenticationMiddleware} și \textit{AuthorizationMiddleware} se ocupă de autentificarea 
și autorizarea API-ului, luând JWT token-ul din \textit{Authorization} header, și îl validează
folosind API-ul de la Google.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/GoogleAuthorization.png}
    \caption{Verificare \textit{AccessToken} folosind Google API.}
    \label{fig:GoogleAuthorization}
\end{figure}

Pentru a face Google API conștient despre existența aplicației și token-ului pe care user-ul îl obține
prin autentificarea pe Client, în Google Console, se creează un \textit{Credential} pentru proiect.
Redirect URIs și request browser sunt reprezentate de Client URL (de acolo se apelează autentificarea).

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/GoogleConfig.png}
    \caption{Configurația Google Credentials.}
    \label{fig:GoogleConfig}
\end{figure}

\textit{TimeTrigger} functions reprezintă funcțiile ce se auto-apelează la o perioadă de timp configurată.
FastRide folosește un acest tip de function pentru a interoga din 5 în 5 secunde tabelul generat
de Durable Orchestation în scopul de a găsi curse ce se află în progres și de a le notfica 
Client-ului prin SignalR.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/TimeTrigger.png}
    \caption{TimeTrigger function ce interoghează Durable tables și notifică utilizatorii despre curse lor ce sunt în desfășurare.}
    \label{fig:TimeTrigger}
\end{figure}
Aceasta caută orchestrările ce se află în \textit{Pending}, \textit{Running} sau \textit{Suspended},
citește proprietatea \textit{CustomStatus} unde se regăsesc informațiile complete ale cursei și 
le returnează pentru fiecare grup de utilizatori ce se află în parcursul unei curse (\textit{GroupName} este \textit{ride.Id}).

\textit{SignalRTrigger} sunt function-urile ce ascultă la un canal WebSocket pentru SignalR, dar sunt și capabile să returneze
un mesaj pe acest canal. Acestea sunt folosite pentru comunicarea în timp real cu Client-ul și au rolul de a notifica 
utilizatorii despre diferite acțiuni ce trebuie sa le facă (ex: plată, acceptare cursă, etc).
Acest tip de funcții folosesc un \textit{eventType} ca și identificator pentru a notifica utilizatorii ce sunt
conectați la canal. Utilizatorii pot fi grupați pe în grupuri pentru a trimite mesaje doar către un 
anumit grup, însă se pot trimite mesaje și direct către un utilizator specific.

FastRide folosește grupurile pentru a grupa utilizatorii per orașe, astfel cei din Craiova nu pot 
vedea și nu pot primi mesaje de la cei din București, spre exemplu. Grupurile se mai folosesc și 
pentru a identifica doi utilizatori ce se află într-o cursă, astfel în momentul în care o cursă se inițiază,
atât șoferul cât și clientul, părăsesc automat gurpul din care fac parte (o combinație dintre țară, județ și oraș) 
și se înscriu la grupul ce se formează din ID-ul cursei generat la creeare.

Pentru a se conecta la canalul de SignalR și pentru a se înscrie într-un grup sau pentru
a părăsi un grup, Client-ul trebui sa apeleze câteva metode care indică aceste \textit{actions}.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/JoinUser.png}
    \includegraphics[width=14cm]{Assets/RemoveUser.png}
    \caption{Înscrierea și ștergerea unui utilizator din grup.}
    \label{fig:JoinRemoveUser}
\end{figure}

Pentru ca server-ul SignalR să înregistreze acțiunile aferente, Server-ul 
trebuie să returneze un \textit{SignalRGroupAction}. Pentru restul notificările 
se folosește \textit{SignalRMessageAction}.

Conectarea la SignalR de către utilizator și notificarea că a fost conectat sau 
deconectat cu succes se fac prin metodele de mai jos:
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/negotiate.png}
    \includegraphics[width=14cm]{Assets/onconnected.png}
    \includegraphics[width=14cm]{Assets/ondisconnected.png}
    \caption{Negotiate, conectarea și deconectarea unui utilizator de la conexiune SignalR.}
    \label{fig:negotiateConnectDisconnect}
\end{figure}
Astfel, în momentul în care un șofer este conectat sau deconectat, se poate actualiza
tabela \textit{OnlineDrivers}.

\textit{Orchestrations} sunt Azure Functions ce pot rula mai mult de 5 minute, ce își păstrează
state-ul în tabele, astfel încât indiferent de ce se întâmplă cu runtime-ul aplicației,
acestea își continuă execuția fără a relua tot procesul.

În proiect, există o singură funcție de acest gen, ce se ocupă cu flow management-ul unei curse.
Astfel, ea primește ca și input, un request ce conține \textit{User} (clientul), locul de unde se inițiază
cursa și destinația dorită. La fiecare pas, aceste infomații se actualizează și 
se salvează în coloana specială a Durable Orchestrations, \textit{CustomStatus}, totodată, modificând și status-ul
cursei.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/saveCustomStatus.png}
    \caption{Salvarea în \textit{CustomStatus} a request-ului inițial.}
    \label{fig:saveCustomStatus}
\end{figure}

Mai departe, aplicația calculează prețul cursei și trimite către utilizator un request de confirmare a cursei.
Pentru a aștepta răspuns, Durable Orchestrations folosesc evenimente pe care le așteaptă:
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/waitForEvent.png}
    \caption{Trimiterea confimării către utilizator și așteptarea răspunsului.}
    \label{fig:waitForEvent}
\end{figure}
Pentru a calcula prețul se folosește următoarea formulă:
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/calculatePrice.png}
    \caption{Calcularea prețului cursei.}
    \label{fig:calculatePrice}
\end{figure}
Dacă s-a acceptat, urmează să se inițieze plata, astfel, Server-ul se ocupă cu creearea
unui \textit{PaymentIntent} ce se poate folosi pentru a se realiza plata cu succes. Fără acest intenționare,
Stripe nu știe să autentifice request-ul de plată.
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/intent.png}
    \caption{Crearea \textit{PaymentIntent}-utului prin Stripe.}
    \label{fig:intent}
\end{figure}
Mai departe, după ce plata s-a procesat cu success, începe să se caute un șofer pentru cursă.
todo

La orice pas, dacă utilizatorul anulează fie confirmarea, fie plata, fie nu se găsește un șofer, cursa intră într-un status
terminal, setând proprietatea \textit{CompletedStatus} cu un status aferent acțiunii.
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{Assets/cancelFlow.png}
    \caption{Anularea cursei dacă plata nu s-a procesat, a fost intenționat anulată sau nu s-a găsit un șofer.}
    \label{fig:cancelFlow}
\end{figure}
Delay-urile au rolul de a face posibilă așteptarea ca și utilizatorul să primească aceste informații, altfel totul ar fi instant.


\subsection{Client-side}
blazor wasm si cum merge, cum apeleaza backendul
despre map si background serv§ices
\section{Comunicarea între componente}
diagrama de cum comunica aplicatia
\subsection{Autentificare și autorizare}
\subsection{Pagina admin-ului}