\chapter{TEHNOLOGII ȘI FRAMEWORK-URI FOLOSITE}
\section{C\#}

C\# este un limbaj de programare modern, orientat pe obiect, dezvoltat de Microsoft și lansat în anul 2000, ca parte a inițiativei .NET. A fost creat sub conducerea lui Anders Hejlsberg, același care a contribuit la dezvoltarea limbajului Delphi. Scopul principal al C\# a fost să combine puterea și flexibilitatea limbajelor precum C++ cu simplitatea și siguranța limbajelor moderne, cum ar fi Java. \parencite{charp}

C\# este un limbaj conceput pentru a fi ușor de învățat și folosit, dar suficient de robust pentru aplicații complexe. Este ideal pentru dezvoltarea de aplicații desktop, web, mobile, jocuri (cu Unity), dar și servicii cloud, microservicii și funcții serverless, în special atunci când este combinat cu platforma .NET. \parencite{charp}

Limbajul C\# este orientat pe obiect, adică permite organizarea codului în clase și obiecte, facilitând reutilizarea și întreținerea codului. De asemenea, are suport nativ pentru asincronism (prin \textit{async}/\textit{await}), LINQ pentru interogarea datelor într-un mod elegant și declarativ, și pattern matching pentru expresivitate crescută. \parencite{charp}

C\# a evoluat constant, adăugând funcționalități care îl fac competitiv cu cele mai populare limbaje de programare. Ultimele versiuni aduc îmbunătățiri semnificative în ceea ce privește performanța, claritatea sintaxei și siguranța codului. \parencite{charp}

Este adesea folosit în mediul enterprise datorită integrării excelente cu serviciile Microsoft (Azure, SQL Server, Active Directory etc.) și a ecosistemului .NET, care oferă o platformă stabilă, multiplatformă și bine întreținută. \parencite{charp}

În dezvoltarea aplicațiilor C\#, pentru organizarea codului există conceptele de design patterns, care oferă soluții reutilizabile pentru probleme comune de arhitectură software. \parencite{charp}

Una dintre cele mai utilizate structuri este separarea aplicației în straturi distincte: \textit{Repository} și \textit{Service}. Acest model este specific abordărilor precum Clean Architecture și Domain-Driven Design. \parencite{designPatterns}

Repository-ul este responsabil pentru interacțiunea cu sursa de date, fie că este o bază de date relațională, un storage NoSQL sau un API extern. El oferă o interfață clară pentru operații precum adăugarea, citirea, actualizarea sau ștergerea entităților, abstractizând detaliile concrete de stocare. \parencite{designPatterns}

Service-ul vine deasupra repository-ului și conține logica de business a aplicației. Aici sunt implementate regulile și fluxurile aplicației, validările și transformările de date. Service-ul folosește repository-ul ca sursă de date, dar nu se ocupă direct cu modul în care acestea sunt stocate sau obținute. \parencite{designPatterns}

\section{.NET}

.NET este o platformă de dezvoltare creată de Microsoft, concepută pentru a permite dezvoltatorilor să construiască aplicații performante pentru o varietate largă de dispozitive și sisteme. A fost lansată oficial în anul 2002 sub numele de .NET Framework, fiind destinată exclusiv sistemelor Windows. Scopul principal era de a oferi un cadru unitar, stabil și coerent în care dezvoltatorii să poată crea aplicații desktop și web într-un mod eficient, folosind limbaje precum C\# și VB.NET. \parencite{dotnet}

Pe măsură ce tehnologia a evoluat, Microsoft a început procesul de modernizare a platformei, orientându-se către dezvoltarea multiplatformă și open-source. Astfel, în 2016 a fost lansat .NET Core, o versiune rescrisă și modulară a platformei, capabilă să ruleze pe Windows, Linux și macOS. Aceasta a oferit o arhitectură mai flexibilă și un sistem de distribuție mai eficient, prin intermediul pachetelor NuGet. \parencite{dotnet}

Începând cu .NET 5, lansat în 2020, Microsoft a unificat direcțiile .NET Framework și .NET Core într-o singură platformă, denumită simplu .NET. Această versiune unificată continuă să evolueze, cu îmbunătățiri constante aduse în performanță, suportul pentru limbaje, instrumente de dezvoltare și capabilități cloud. Versiunile recente, cum ar fi .NET 6, .NET 7 și .NET 8, sunt toate versiuni LTS (Long Term Support) sau standard, folosite pe scară largă în industrie. \parencite{dotnet}

.NET se bazează pe concepte precum CLR (Common Language Runtime), care este motorul de execuție ce gestionează rularea aplicațiilor, și BCL (Base Class Library), o colecție vastă de librării care oferă funcționalități esențiale: lucrul cu fișiere, colecții, rețea, criptare, baze de date și multe altele. De asemenea, platforma oferă suport excelent pentru programarea asincronă, gestionarea memoriei automate prin Garbage Collection, precum și o integrare nativă cu servicii și tehnologii moderne precum Azure, Docker și Kubernetes. \parencite{dotnet}

Prin intermediul .NET, dezvoltatorii pot crea aplicații web (cu ASP.NET), desktop (cu WPF și WinForms), mobile (cu .NET MAUI și Xamarin), servicii API, aplicații cloud, jocuri (prin Unity) și chiar soluții de inteligență artificială sau machine learning. \parencite{dotnet}

\section{Azure Function}
Azure Functions este o platformă serverless dezvoltată de Microsoft care permite rularea codului în cloud fără a fi nevoie să gestionezi infrastructura de servere. Acest model facilitează dezvoltarea rapidă a aplicațiilor și serviciilor scalabile, concentrându-se doar pe logică, nu pe administrarea resurselor. \parencite{azureFunctions}
\\Principalele caracteristici ale Azure Functions sunt:
\begin{itemize}
    \item Execuție event-driven: Funcțiile sunt declanșate automat de evenimente, cum ar fi modificări în baza de date, mesaje din cozi, cereri HTTP, cronometre sau alte surse.
    \item Scalabilitate automată: Azure gestionează în mod automat scalarea funcțiilor în funcție de cerere, asigurând performanță optimă indiferent de volumul de trafic.
    \item Model de plată pay-as-you-go: Se plătește doar pentru timpul efectiv în care codul rulează, fără costuri fixe legate de infrastructură.
    \item Suport pentru mai multe limbaje: C\#, JavaScript, Python, Java, PowerShell și altele pot fi folosite pentru a scrie funcțiile.
\end{itemize}\parencite{azureFunctions}

\subsection{Azure Durable Functions}
Azure Durable Functions reprezintă o extensie a platformei Azure Functions, dezvoltată de Microsoft pentru a facilita crearea de fluxuri de lucru pe termen lung și orchestrarea funcțiilor serverless într-un mod eficient și scalabil. Lansată oficial în 2017, această extensie adaugă capabilități suplimentare funcțiilor serverless tradiționale, permițând dezvoltatorilor să gestioneze procese complexe care implică mai multe funcții interdependente și executate în timp. \parencite{azureDurableFunctions}

Azure Functions, lansat cu un an mai devreme (2016), face parte din suita de servicii serverless computing din Azure și permite rularea de cod fără a fi necesară administrarea explicită a infrastructurii. Totuși, aceste funcții standard au fost concepute pentru execuții rapide, de scurtă durată, ceea ce le făcea mai puțin potrivite pentru procesele care necesită menținerea stării și coordonarea pe termen lung. \parencite{azureDurableFunctions}
\\Pentru a răspunde acestor nevoi, Durable Functions oferă următoarele capabilități:
\begin{itemize}
    \item Orchestrarea funcțiilor de scurtă durată, într-un mod automatizat și declarativ;
    \item Gestionarea stării între apelurile funcțiilor, pe parcursul execuției unui proces complex;
    \item Retry automat și suport pentru scenarii de compensare în caz de eșec.
\end{itemize}\parencite{azureDurableFunctions}

Durable Functions este construit pe baza Durable Task Framework, permițând dezvoltatorilor să scrie cod orchestrat într-un stil secvențial, dar care este transformat automat în execuție asincronă și distribuită, cu păstrarea stării între pași. \parencite{azureDurableFunctions}
\\Scenarii comune de utilizare:
\begin{itemize}
    \item Orchestrarea fluxurilor de lucru - o funcție orchestrator coordonează apelurile către alte funcții, în funcție de anumite condiții sau răspunsuri. De exemplu, poate apela o funcție care extrage date de la un API, apoi, în funcție de rezultat, lansează alte funcții în lanț.
    \item 	Function Chaining (lanțuri de funcții) - mai multe funcții sunt apelate secvențial, iar rezultatul fiecărei funcții este transmis mai departe către următoarea funcție din lanț.
    \item 	Fan-out/Fan-in - o funcție poate declanșa mai multe funcții în paralel (fan-out), după care agregă rezultatele într-un punct comun (fan-in). Acest model este ideal pentru procesarea paralelă a unor seturi mari de date.
    \item 	Gestionarea proceselor de lungă durată - Durable Functions permite execuția de fluxuri care pot dura ore, zile sau chiar luni, menținând starea între pași. Este util în scenarii precum aprobări, procese de onboarding, migrare de date sau procese distribuite în timp.
    \item 	Compensarea acțiunilor (Saga Pattern) - În fluxuri unde mai multe acțiuni trebuie executate într-o ordine strictă, Durable Functions permite implementarea de logici de rollback sau compensare în caz de eșec, asigurând consistența procesului.
    \item 	Funcții temporizate (Timer Functions) - Orchestratorii pot programa funcții să ruleze după o întârziere sau la anumite intervale. Acestea sunt utile în procese automate, monitorizări periodice sau trimiterea de notificări programate.
\end{itemize}\parencite{azureDurableFunctions}

Lucrarea folosește Azure Functions, în special Azure Durable Functions pentru a face posibilă procesarea și menținerea legăturii între 2 utilizatori pe parcursul cursei, indiferent de circumstațele actuale (utilizatorul face Refresh sau aplicația își ia Restart).

\section{Azure Table Storage}
Azure Table Storage este un serviciu creat de Microsoft ca parte a suitei Azure Storage, gândit pentru a oferi o soluție simplă, scalabilă și extrem de rapidă pentru stocarea datelor structurate în format NoSQL. Table Storage nu impune o schemă fixă, ceea ce înseamnă că fiecare entitate dintr-o tabelă poate avea un set diferit de proprietăți. Acest lucru îl face ideal pentru scenarii în care datele sunt variabile sau când flexibilitatea contează mai mult decât relațiile complexe dintre entități. \parencite{azureStorage}

A fost introdus în jurul anului 2010, într-o perioadă în care Microsoft își contura strategia cloud și începea să ofere servicii care să concureze cu AWS. A fost conceput pentru a servi aplicații la scară mare, care necesită o cantitate mare de scrieri și citiri, dar fără nevoia de tranzacții complexe sau relații între tabele. Scenariile clasice includ loguri, telemetrie, date despre utilizatori, mesaje sau orice tip de evenimente care trebuie stocate rapid și recuperate eficient. \parencite{azureStorage}

Table Storage folosește o structură bazată pe tabele care conțin entități, fiecare identificată printr-o combinație unică de \textit{PartitionKey} și \textit{RowKey}. Această combinație asigură performanță crescută la căutare, mai ales atunci când datele sunt distribuite corect în funcție de \textit{PartitionKey}. Fiind un serviciu NoSQL, nu există conceptul de join-uri sau constrângeri între entități, dar în schimb se câștigă foarte mult la capitolul viteză și scalabilitate. \parencite{azureStorage}

În timp, Table Storage a devenit o alegere populară pentru aplicațiile moderne, în special cele distribuite, microservicii sau orice alt sistem care are nevoie de o bază de date simplă, ieftină și elastică. Este integrat profund în ecosistemul Azure, ceea ce înseamnă că poate fi combinat ușor cu alte servicii precum Azure Functions, Logic Apps sau Azure Event Grid, făcându-l extrem de versatil în arhitecturi cloud-native. \parencite{azureStorage}

Azure Storage reprezintă structura de stocare pentru lucrarea de față, datorită numărului scăzut de dependințe și tabele utilizate și vitezei de care dispune.

\subsection{Azurite}

Azurite este un emulator local creat de Microsoft pentru serviciile de stocare din Azure. A fost conceput ca un instrument de dezvoltare care le permite programatorilor să lucreze cu Azure Blob Storage, Queue Storage și Table Storage pe propriul calculator, fără a avea nevoie de o conexiune activă la platforma Azure. Practic, simulează comportamentul serviciilor reale, oferind o experiență de dezvoltare aproape identică cu mediul de producție. \parencite{azurite}

A apărut ca succesor al emulatorului mai vechi Microsoft Azure Storage Emulator, care era limitat la Windows. Azurite, în schimb, este cross-platform, fiind scris în Node.js și disponibil ca pachet NPM sau container Docker. Asta îl face ideal pentru proiecte care rulează pe macOS, Linux sau Windows, fie în linie de comandă, fie integrat în Visual Studio Code. \parencite{azurite}

Oferă un mediu de testare local rapid și fără costuri, în care dezvoltatorii pot simula citiri, scrieri, partajări și alerte, fără riscul de a consuma resurse reale în Azure sau de a introduce erori în datele live. Este frecvent folosit în timpul dezvoltării și al testării automate, mai ales în scenarii unde aplicația interacționează frecvent cu Table Storage sau Blob-uri. \parencite{azurite}

Azurite ajută la accelerarea dezvoltării, reduce costurile și elimină nevoia de conexiune constantă la cloud, păstrând în același timp consistența cu ceea ce se întâmplă în Azure real. Din acest motiv este folosit și în proiectul curent.

\section{LINQ}

LINQ (Language Integrated Query) este o componentă a limbajului C\# care permite interogarea colecțiilor de date într-un mod declarat, expresiv și tip-safe, folosind o sintaxă integrată direct în limbaj. LINQ oferă o punte între programarea orientată pe obiecte și interogarea datelor, permițând manipularea colecțiilor precum liste, array-uri, baze de date sau fișiere XML. \parencite{linq}

Prin LINQ, sintaxa este similară celei din SQL, dar adaptată paradigmei C\# și poate fi aplicată atât în memorie (de exemplu, asupra listelor), cât și asupra surselor externe, cum ar fi Entity Framework sau XML. \parencite{linq}

În contextul Azure Table Storage, LINQ poate fi folosit pentru a interoga datele stocate într-un mod expresiv, dar trebuie menționat că suportul LINQ este mai limitat comparativ cu interogările LINQ în memorie sau cu Entity Framework. Azure Table Storage este un sistem NoSQL key-value, iar interogările se bazează pe filtrarea entităților în funcție de \textit{PartitionKey}, \textit{RowKey} și alte proprietăți. \parencite{linq}

Pentru a lucra cu LINQ în Azure Table Storage, se folosește de regulă SDK-ul oficial (\textit{Azure.Data.Tables}) și clase ca \textit{TableClient} sau \textit{TableServiceClient}.  \parencite{linq}

Utilizarea LINQ peste \textit{TableQueryable<T>} (în SDK-uri mai vechi) sau direct cu \textit{TableClient.Query<T>()} în SDK-ul modern, există access la o subset de metode LINQ compatibile cu server-side query translation. Cele mai importante metode disponibile sunt:
\begin{itemize}
    \item Where() – pentru a filtra datele după proprietăți simple
    \item Take() – pentru a limita numărul de rezultate returnate
    \item Select() – parțial suportat, pentru a proiecta obiectele într-o formă nouă
    \item OrderBy() și OrderByDescending() – doar în anumite condiții și nu întotdeauna disponibile, în funcție de SDK
\end{itemize}
\parencite{linq}

\section{HyperText Markup Language (HTML)}

HTML, prescurtarea de la HyperText Markup Language, este limbajul standard folosit pentru a structura și
a afișa conținut pe web. A apărut la începutul anilor ’90, dezvoltat de Tim Berners-Lee, și a stat la baza
creării primelor pagini web din internetul modern. HTML nu este un limbaj de programare propriu-zis, ci un
limbaj de marcare, ceea ce înseamnă că este folosit pentru a indica browserului cum să interpreteze și să
afișeze diverse elemente: titluri, paragrafe, imagini, linkuri, liste, formulare și multe altele. \parencite{htmlcss}

Documentele HTML sunt compuse din etichete (tag-uri) care înconjoară conținutul pentru a-i da semnificație.
De exemplu, \textit{<p>} definește un paragraf, \textit{<a>} un link, iar \textit{<img>} o imagine. Acestea sunt în mod obișnuit
organizate într-o structură ierarhică, pornind de la o etichetă principală \textit{<html>}, care conține două secțiuni:
\textit{<head>} (cu metadate, titlu, legături către stiluri și scripturi) și \textit{<body>} (unde se află efectiv conținutul
afișat în pagină). \parencite{htmlcss}

HTML este strâns legat de CSS (pentru stilizare) și JavaScript (pentru interactivitate). Împreună, aceste trei
tehnologii formează „scheletul” oricărei aplicații web. De-a lungul timpului, HTML a evoluat semnificativ,
ajungând astăzi la versiunea HTML5, care introduce elemente semantice precum \textit{<article>}, \textit{<section>}, \textit{<header>},
dar și suport nativ pentru video, audio, canvas și multe altele. \parencite{htmlcss}

\section{Cascading Style SHeets (CSS)}

CSS, prescurtare de la Cascading Style Sheets, este limbajul folosit pentru a stiliza și prezenta elementele
HTML pe paginile web. A fost creat pentru a separa structura (HTML) de aspect (culori, fonturi, poziționare),
permițând dezvoltatorilor să creeze interfețe coerente, atractive și responsive. \parencite{htmlcss}

CSS funcționează pe baza regulilor, fiecare formată dintr-un selector (care stabilește ce elemente HTML vor
fi afectate) și un bloc de declarații (care definesc stilul, de exemplu: culoare, dimensiune, margini etc.).
De exemplu, o regulă simplă care colorează tot textul paragrafelor în roșu ar arăta:
\begin{verbatim}
p {
    color: red;
}  
\end{verbatim}

Fiind „cascading” (în cascadă), CSS aplică regulile în funcție de mai mulți factori: specificitate, ordinea
de apariție, și dacă stilurile sunt definite inline, în fișiere externe sau într-un \textit{<style>} din HTML. \parencite{htmlcss}
\\CSS permite:
\begin{itemize}
    \item controlul layout-ului paginii (prin \textit{Flexbox}, \textit{Grid} etc.);
    \item personalizarea completă a vizualului (fonturi, tranziții, animații);
    \item adaptarea conținutului pentru diferite dispozitive (prin media queries, pentru responsive design).
\end{itemize}
\parencite{htmlcss}

CSS poate fi organizat și modularizat cu ajutorul unor preprocesatoare (ex. SASS, LESS)
sau poate fi gestionat direct în fișierele componentelor, cum se întâmplă în Blazor, React sau Angular. În
Blazor, de exemplu, pot exista fișiere \textit{.razor.css} care afectează stilul unei componente fără a influența alte
părți ale aplicației. \parencite{htmlcss}

CSS este responsabil de aspectul și senzația vizuală a aplicației, completând structura oferită
de HTML și funcționalitatea livrată de C\#, JavaScript sau alte limbaje. \parencite{htmlcss}

\section{Bootstrap}


Bootstrap este un framework front-end open-source dezvoltat inițial de Twitter, lansat pentru prima dată
în 2011, cu scopul de a oferi un set unitar și rapid de unelte pentru crearea interfețelor web moderne.
Este construit în jurul a trei tehnologii principale: HTML, CSS și JavaScript, și oferă o colecție de
componente predefinite, stiluri și funcționalități interactive care pot fi integrate rapid într-o aplicație. \parencite{htmlcss}

Unul dintre cele mai importante avantaje ale Bootstrap este sistemul său de grid responsive (bazat inițial
pe 12 coloane), care permite construirea layout-urilor flexibile, adaptabile pentru orice dimensiune de
ecran, de la telefoane mobile până la monitoare mari. \parencite{htmlcss}
\\Bootstrap include o varietate de:
\begin{itemize}
    \item componente UI (buttoane, formulare, alerte, carduri, navigație etc.),
    \item plugin-uri JavaScript (dropdown-uri, carusele, modale, tooltip-uri etc.),
    \item variabile și mixin-uri Sass pentru personalizare avansată.
\end{itemize}
\parencite{htmlcss}

Dezvoltatorii pot folosi clase CSS predefinite (ex: \textit{btn btn-primary}, \textit{d-flex}, \textit{text-center}) pentru a aplica
rapid stiluri fără a scrie cod CSS de la zero. Această abordare reduce timpul de dezvoltare și asigură un
aspect uniform al aplicației.\parencite{htmlcss}

În Blazor, Bootstrap este frecvent utilizat pentru a stiliza rapid componentele \textit{.razor}. Fiind un framework
agnostic (nu depinde de un anumit limbaj de programare back-end), poate fi integrat cu ușurință și în proiecte
.NET, ASP.NET sau Blazor. În special în Blazor WebAssembly, este obișnuit să se includă Bootstrap direct în
\textit{index.html} și să se aplice clasele Bootstrap componentelor din \textit{.razor}.

\section{Blazor}
Blazor este un framework open-source dezvoltat de Microsoft, lansat oficial în 2018, ca parte a ecosistemului .NET. Numele „Blazor” este format din cuvintele „Browser” și „Razor”, evidențiind utilizarea motorului Razor pentru redarea componentelor web direct în browser. \parencite{blazor}

Scopul principal al Blazor este de a permite dezvoltatorilor .NET să creeze aplicații web interactive fără a apela la JavaScript, oferind o alternativă la framework-uri front-end precum React, Angular sau Vue.js. Utilizând limbajul C\# și întreg ecosistemul .NET, Blazor a devenit rapid o opțiune atractivă pentru dezvoltatorii familiarizați cu tehnologiile Microsoft, facilitând dezvoltarea de aplicații full-stack doar cu .NET. \parencite{blazor}
\\Blazor este disponibil în două variante principale:
\begin{itemize}
    \item Blazor Server (2019): Aplicația rulează pe server, iar interacțiunea cu utilizatorul este gestionată în timp real prin SignalR. Această variantă oferă performanțe ridicate și un consum redus de resurse pe client, dar necesită o conexiune constantă la server.
    \item Blazor WebAssembly (2020): Codul C\# este compilat în WebAssembly și rulează direct în browser, eliminând nevoia unei conexiuni continue la server. Aceasta permite dezvoltarea de aplicații web care pot funcționa și offline.
\end{itemize}\parencite{blazor}
\\Utilizări principale ale Blazor:
\begin{itemize}
    \item Aplicații web interactive (SPA - Single Page Applications): Blazor permite dezvoltarea de aplicații de tip SPA, în care navigarea și interacțiunile cu utilizatorul se realizează fără reîncărcarea completă a paginii, oferind o experiență fluidă și modernă.
    \item Aplicații WebAssembly: Cu Blazor WebAssembly, aplicațiile pot rula complet în browser, reducând latențele și oferind posibilitatea de a crea aplicații offline sau cu funcționare locală.
    \item Aplicații server-side: Blazor Server este ideal pentru aplicații care necesită control sporit asupra datelor și un răspuns în timp real. Prin SignalR, modificările din UI sunt reflectate instant, fără apeluri repetate la server.
    \item Aplicații enterprise: Datorită integrării excelente cu ecosistemul .NET, Blazor este preferat în mediul enterprise pentru reutilizarea codului existent, integrarea ușoară a logicii de business, autentificării, bazelor de date și serviciilor API.
\end{itemize}\parencite{blazor}

În Blazor, HTML-ul este folosit într-un contextpuțin diferit: HTML-ul devine parte dintr-un fișier .razor,
care combină markup-ul (HTML) cu C\# într-o singură componentă.

Blazor este un framework dezvoltat de Microsoft, parte din ecosistemul .NET, care permite scrierea de
aplicații web interactive folosind C\# în loc de JavaScript. Cu toate acestea, interfața aplicației tot
cu HTML se definește. De exemplu, pentru a creea un buton, un formular, o listă sau un container de
conținut, vse vor folosi aceleași etichete HTML standard, ca în orice aplicație web tradițională. \parencite{blazor}
\\Diferența esențială e că în Blazor:
\begin{itemize}
    \item  se pot lega date (\textit{data binding}) direct în HTML folosind sintaxa @ (ex. @someProperty);
    \item  se poate interacționa cu evenimente ca \textit{@onclick}, \textit{@oninput}, etc., legându-le direct la metode din C\#;
    \item  se pot include componente (echivalente cu funcții sau clase UI reutilizabile) folosind HTML-like tags:
          \textit{<MyComponent />}.
\end{itemize}
\parencite{blazor}

De exemplu, în loc să se scrie un buton cu JavaScript care să modifice o valoare, în Blazor se va scrie un
buton HTML cu un \textit{@onclick} care apelează o metodă C\#.

Proiectul de licență folosește Blazor WebAssembly pentru ca se doreste o platfoma destul de light pentru utilizator care poate fi folosită și în zone scăzute de internet.
Blazor Server folosește comunicarea cu un server comun prin SignalR ceea ce necesită o conexiune permanentă la internet. Iar la un volum mare de utilizatori, acest canal poate deveni lent.

\section{MudBlazor}

MudBlazor este o bibliotecă de componente UI open-source pentru Blazor, construită cu scopul de a oferi o
experiență modernă și coerentă de design bazată pe Material Design, dar adaptată complet ecosistemului .NET.
A fost creată pentru a permite dezvoltatorilor să construiască aplicații Blazor atractive și funcționale fără
a apela la JavaScript extern sau framework-uri CSS precum Bootstrap. \parencite{mudblazor}

MudBlazor a fost gândit pentru Blazor și folosește avantajele acestuia, cum ar fi bindingul bidirecțional și
componentizarea simplă, pentru a crea o experiență de dezvoltare fluidă. \parencite{mudblazor}
\\Cu MudBlazor, se pot folosi componente precum:
\begin{itemize}
    \item MudButton, MudTextField, MudSelect, MudDialog, MudTable, MudCard
    \item MudLayout și MudDrawer pentru crearea de interfețe responsive
    \item MudTheme pentru personalizare ușoară a temei aplicației (culori, fonturi, spacing)
\end{itemize}
\parencite{mudblazor}

Un mare avantaj este că toate componentele sunt complet compatibile cu codul C\# și interacțiunile din Blazor,
nu e nevoie de JavaScript pentru funcționalități precum dialoguri, notificări, meniuri sau validarea
formularelor. \parencite{mudblazor}
\\MudBlazor vine și cu suport pentru:
\begin{itemize}
    \item Dark mode nativ
    \item Validare fluentă a formularelor
    \item Tablouri de bord moderne cu grafică, animații și layout-uri fluide
\end{itemize}
\parencite{mudblazor}

Este ideal pentru aplicații enterprise sau proiecte în care se dorește o interfață consistentă și ușor de
întreținut în timp. \parencite{mudblazor}
\\De asemenea, documentația MudBlazor este completă și oferă exemple clare pentru toate
componentele.

\section{SignalR}
WebSockets este un protocol de comunicație care permite o conexiune bidirecțională, persistentă și full-duplex între un client (de exemplu, un browser web) și un server, facilitând transmiterea rapidă și continuă a datelor în timp real fără a reîncarca pagina. \parencite{signalR}

SignalR este o bibliotecă dezvoltată de Microsoft care facilitează comunicarea în timp real între aplicațiile web, mobile sau desktop și servere. Lansată în 2011 și integrată ulterior în ecosistemul ASP.NET Core, SignalR permite actualizări și notificări instantanee fără a fi nevoie de reîncărcarea paginile web. \parencite{signalR}

Înainte de SignalR, comunicarea bidirecțională în timp real era dificilă și adesea implementată prin tehnici ineficiente precum polling sau long-polling, care consumau multe resurse. SignalR a simplificat acest proces prin integrarea automată a protocolului WebSockets, care oferă o conexiune persistentă și eficientă între client și server. \parencite{signalR}

Cu apariția ASP.NET Core, SignalR a fost reproiectat pentru a fi mai performant și scalabil, suportând diverse metode de transport și oferind o experiență optimă indiferent de mediu. \parencite{signalR}
\\SignalR folosește automat cel mai potrivit mecanism de comunicare, în funcție de capabilitățile clientului și ale serverului:
\begin{itemize}
    \item WebSockets: Protocolul principal, oferind o conexiune rapidă și bidirecțională.
    \item Server-Sent Events (SSE): Permite serverului să trimită actualizări către client printr-o conexiune HTTP deschisă.
    \item Long Polling: Metoda de rezervă, în care clientul face cereri repetate pentru a verifica noutățile atunci când celelalte opțiuni nu sunt disponibile.
\end{itemize}\parencite{signalR}

SignalR este ideal pentru aplicații care necesită actualizări în timp real, cum ar fi chat-uri, notificări, dashboard-uri live sau colaborare online.
Acesta ajută componentele proiectului FastRide să comunice fără a fi nevoie de acțiuni manuale ale utilizatorului sau reîncărcarea paginii.

\subsection{SignalR Server Emulator}

SignalR este o bibliotecă dezvoltată de Microsoft care facilitează comunicarea bidirecțională în timp real între server și client. Este folosită în aplicații precum chat-uri, sisteme de notificare live, jocuri multiplayer sau aplicații colaborative.
\parencite{signalREmulator}
\\În timpul dezvoltării, conectarea la un serviciu SignalR real (precum Azure SignalR Service) poate fi:
\begin{itemize}
    \item mai costisitoare (în special pentru testare frecventă),
    \item dependentă de internet sau de configurări complexe,
    \item dificil de controlat în ceea ce privește scenarii de test (ex. simularea mai multor utilizatori sau pierderi de conexiune).
\end{itemize}
\parencite{signalREmulator}

SignalR Server Emulator este un instrument util în special în etapa de dezvoltare și testare a aplicațiilor web sau mobile care folosesc comunicarea în timp real prin SignalR. Scopul său este să emuleze comportamentul unui server SignalR real, astfel încât dezvoltatorii să poată testa interacțiuni în timp real (mesaje, notificări, actualizări de stare etc.) fără a depinde de un backend implementat complet sau de infrastructura Azure. \parencite{signalREmulator}

SignalR Server Emulator rezolvă probleme enumerate prin rularea locală, oferirea unei interfețe sau API-uri care simulează semnalarea și transmiterea mesajelor, integrarea ușoară cu aplicațiile existente care folosesc SignalR. \parencite{signalREmulator}

Emulatorul pornește un hub SignalR local (de obicei într-un ASP.NET Core server simplificat) care acceptă conexiuni WebSocket de la clienți (browser sau aplicații mobile), trimite mesaje simulate (manual sau automat), permite testarea scenariilor cum ar fi broadcast, mesaje către grupuri, reconectări sau deconectări. \parencite{signalREmulator}

Totuși emulatorul nu înlocuiește complet un serviciu real precum Azure SignalR. Nu oferă scalabilitate mare, autentificare complexă, routing distribuit sau integrare cu alte servicii cloud. \parencite{signalREmulator}

Pentru a putea face posibilă testarea aplicației prezente cu o conexiune SignalR, atunci se folosește SignalR Emulator.

\section{Refit API}

Refit (abreviere de la Rest Service Interface) este o bibliotecă open-source pentru platforma .NET, dezvoltată cu scopul de a simplifica interacțiunea aplicațiilor cu API-uri REST. Aceasta permite definirea interfețelor API într-un mod declarativ, bazat pe atribute, înlocuind codul tradițional de apel HTTP scris manual cu o abordare mult mai concisă și lizibilă. \parencite{refit}

Refit a fost inspirat de biblioteca Retrofit, utilizată în ecosistemul Android. A fost creată de Paul Betts și continuă să fie întreținută de comunitatea .NET. Scopul său este acela de a automatiza procesul de trimitere a cererilor HTTP și de a deserializa răspunsurile în obiecte C\#, oferind astfel o metodă elegantă și productivă de a lucra cu API-uri externe. \parencite{refit}

Refit se bazează pe conceptul de interfață C\# decorată cu atribute, care definește metodele corespunzătoare endpoint-urilor unui serviciu REST. La momentul execuției, biblioteca generează automat o implementare a acestei interfețe folosind \textit{RestService.For<T>()}. Această implementare utilizează intern \textit{HttpClient}, dar ascunde complet complexitatea acestuia. \parencite{refit}

\section{Leaflet și Routing Machine}

Leaflet este o bibliotecă JavaScript open-source pentru hărți interactive, recunoscută pentru dimensiunea redusă, performanța ridicată și ușurința în utilizare. A fost creată pentru a fi ușor de integrat în aplicații web și este folosită pe scară largă în proiecte care necesită afișarea hărților și a datelor geospațiale într-un mod interactiv. Datorită versatilității sale, Leaflet poate funcționa eficient pe toate browserele moderne și oferă suport nativ pentru interacțiuni uzuale precum zoom, pan, adăugarea de markere și pop-up-uri. \parencite{leaflet}

Pentru aplicațiile care necesită trasarea unei rute între două sau mai multe puncte, se poate integra pluginul Leaflet Routing Machine, care adaugă funcționalitatea de navigare și calcul de rute direct în hartă. Acesta se bazează în general pe servicii externe precum OSRM (Open Source Routing Machine), GraphHopper sau Mapbox Directions pentru a calcula rutele, oferind o funcționalitate ce include afișarea traseelor, inclusiv cu indicații pas cu pas și actualizări în timp real. \parencite{leaflet}

Într-o aplicație web, Leaflet și Routing Machine pot lucra împreună pentru a permite utilizatorilor să vizualizeze pe hartă locații relevante, să genereze rute între puncte selectate și să primească detalii despre distanță, durată și drumuri parcurse și totul gratis, de aceea se utilizează și în proiectul FastRide.

\section{Stripe}
Stripe este o platformă globală de procesare a plăților, fondată în 2010 de frații Patrick și
John Collison. Aceasta a fost creată pentru a permite afacerilor și dezvoltatorilor să accepte plăți
online în mod simplu și sigur. Stripe a devenit rapid unul dintre cei mai populari furnizori de
soluții de plăți digitale, datorită ușurinței de integrare, suportului pentru diverse metode de plată
și disponibilității în multiple țări. \parencite{stripe}

Stripe a fost fondată într-o perioadă în care comerțul online era în creștere, dar soluțiile de
plată disponibile erau adesea greoaie sau complexe de implementat. Frații Collison au observat o
oportunitate de a crea o platformă care să facă procesul de integrare a plăților în site-uri web și
aplicații mult mai simplu pentru dezvoltatori. Stripe a fost lansată oficial în 2011, cu misiunea de
a moderniza plățile online și de a oferi soluții intuitive pentru afaceri de toate dimensiunile. \parencite{stripe}

Stripe este o platformă populară pentru procesarea plăților online, iar în cod, interacțiunea cu Stripe se face de obicei prin intermediul unui SDK oficial (cum ar fi Stripe.net în C\#), care comunică cu API-ul Stripe. Tot fluxul pornește de la inițierea unei acțiuni de plată sau de verificare a cardului, iar implementarea în cod respectă pașii tipici ai unui flux de plată securizat și asincron. \parencite{stripe}

Într-un flux obișnuit, aplicația backend creează un \textit{PaymentIntent} sau un \textit{SetupIntent}, în funcție de ceea ce se dorește, adică dacă se vrea să se încaseze o sumă sau doar să se verifice și să se salveze un card pentru o plată ulterioară. Odată ce intent-ul a fost creat, backend-ul primește un \textit{client\_secret}, care este trimis către frontend. \parencite{stripe}

Pe frontend, Stripe.js sau Stripe Elements este folosit pentru a colecta datele cardului și a le trimite către Stripe, fără ca serverul să vadă sau să stocheze datele sensibile. Cu acel \textit{client\_secret}, frontend-ul finalizează interacțiunea și Stripe se ocupă de autorizarea plății sau a cardului. \parencite{stripe}

După ce Stripe procesează totul, trimite un răspuns către backend prin webhook-uri (de exemplu, când o plată a fost finalizată cu succes, sau când un card a fost salvat), iar aplicația poate reacționa la aceste evenimente, de exemplu, salvând un ID de client Stripe sau marcând o comandă ca fiind plătită. \parencite{stripe}

Codul doar configurează cererea, transmite comenzile către Stripe și reacționează la rezultatele oferite de Stripe prin webhook-uri. Acest model oferă securitate, scalabilitate și conformitate cu standardele precum PCI-DSS.